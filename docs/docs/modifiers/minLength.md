---
id: minLength
title: minLength
---

The `minLength` modifier is used to contraint length of `string` or `array` values.

```ts
const atLeastTwoCharsValidator = validate(minLength(2)(string()));

// Returns 'ok'
const ok = atLeastTwoCharsValidator('ok');

// Throws ValidationError
const notOk = atLeastTwoCharsValidator('?');
```

The `minLength` modifier also changes the return validation type when used on arrays. In such case arrays become tuples with given number of elements:

```ts
const len10Validator = validate(minLength(10)(array(number())));
// type of result is
// readonly [number, number, number, number, number, number, number, number, number, number, ...number[]]
const result = validate(len10Validator)([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);
```

As a result, it makes using such arrays/tuples more typesafe. Notice how the type of the `eleventhElement` is different:

```ts
// number
const firstElement = result[0];
// number
const tenthElement = result[9];
// number | undefined
const eleventhElement = result[10];
```

## Type instantiation is excessively deep and possibly infinite

On rare occasions you may come across the following TypeScript error: _Type instantiation is excessively deep and possibly infinite.ts(2589)_. It's a limitation of the TypeScript compiler when used on very deeply nested conditional types such as the tuples generated by the `minLength` modifier.

Should this issue ever occur to you, please override the inferred generic parameter with `number`:

```ts
// errors in compile-time
const whoopsieDaisyValidator = validate(minLength(100000)(array(number())))([]);

// fallback to less-typesafe array: readonly number[]
const better = validate(minLength<number>(100000)(array(number())))([]);
```
